"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getValidImportUrlFactory = exports.resolveNodeModuleToDenoModuleFactory = void 0;
const ModuleAddress_1 = require("../types/ModuleAddress");
const is404_1 = require("../../tools/is404");
const urlJoin_1 = require("../../tools/urlJoin");
const get_github_default_branch_name_1 = require("get-github-default-branch-name");
const getThirdPartyDenoModuleInfos_1 = require("../getThirdPartyDenoModuleInfos");
const node_fetch_1 = require("node-fetch");
const commentJson = require("comment-json");
const path = require("path");
const getCurrentStdVersion_1 = require("../getCurrentStdVersion");
const addCache_1 = require("../../tools/addCache");
const toPosix_1 = require("../../tools/toPosix");
const tsafe_1 = require("tsafe");
const githubTags_1 = require("../../tools/githubTags");
const isInsideOrIsDir_1 = require("../../tools/isInsideOrIsDir");
const knownPorts_1 = require("./knownPorts");
const assert_1 = require("tsafe/assert");
const exclude_1 = require("tsafe/exclude");
const fileAndContent_1 = require("../config/fileAndContent");
const parseParams_1 = require("../config/parseParams");
function resolveNodeModuleToDenoModuleFactory(params) {
    const { log, getInstalledVersionPackageJson } = params;
    const { denoPorts } = (() => {
        const denoPorts = {};
        [knownPorts_1.knownPorts.third_party, knownPorts_1.knownPorts.builtins, params.userProvidedPorts].forEach(record => Object.keys(record).forEach(nodeModuleName => (denoPorts[nodeModuleName] = record[nodeModuleName])));
        return { denoPorts };
    })();
    const allDependencies = {
        ...params.dependencies,
        ...params.devDependencies
    };
    const isInUserProvidedPort = (nodeModuleName) => nodeModuleName in params.userProvidedPorts;
    const resolveNodeModuleToDenoModule = (0, addCache_1.addCache)(async (params) => {
        const { nodeModuleName //js-yaml
         } = params;
        walk: {
            if (nodeModuleName in allDependencies) {
                break walk;
            }
            if (!(nodeModuleName in denoPorts)) {
                return { "result": "UNKNOWN BUILTIN" };
            }
            const getValidImportUrlFactoryResult = await (0, exports.getValidImportUrlFactory)({
                "moduleAddress": ModuleAddress_1.ModuleAddress.parse(denoPorts[nodeModuleName]),
                "desc": "NOT LISTED AS A DEPENDENCY (PROBABLY NODE BUILTIN)"
            });
            if (!getValidImportUrlFactoryResult.couldConnect) {
                return { "result": "UNKNOWN BUILTIN" };
            }
            const { getValidImportUrl } = getValidImportUrlFactoryResult;
            return {
                "result": "SUCCESS",
                getValidImportUrl
            };
        }
        let gitHubRepo = undefined;
        if (ModuleAddress_1.ModuleAddress.GitHubRepo.match(allDependencies[nodeModuleName])) {
            /*
            If we are here then:
            allDependencies[nodeModuleName] === "github:garronej/ts-md5#1.2.7"
            else:
            allDependencies[nodeModuleName] === "^1.2.3"
            */
            gitHubRepo = ModuleAddress_1.ModuleAddress.GitHubRepo.parse(allDependencies[nodeModuleName]);
        }
        const { version, // 3.13.1 (version installed)
        repository: repositoryEntryOfPackageJson } = await getInstalledVersionPackageJson({ nodeModuleName }).catch(() => {
            log([
                `${nodeModuleName} could not be found in the node_module directory`,
                `seems like you needs to re-install your project dependency ( npm install )`
            ].join(" "));
            process.exit(-1);
        });
        if (gitHubRepo === undefined) {
            gitHubRepo = (() => {
                const repositoryUrl = repositoryEntryOfPackageJson === null || repositoryEntryOfPackageJson === void 0 ? void 0 : repositoryEntryOfPackageJson["url"];
                if (!repositoryUrl) {
                    return undefined;
                }
                const [repositoryName, userOrOrg] = repositoryUrl
                    .replace(/\.git$/i, "")
                    .split("/")
                    .filter((s) => !!s)
                    .reverse();
                if (!repositoryName || !userOrOrg) {
                    return undefined;
                }
                return ModuleAddress_1.ModuleAddress.GitHubRepo.parse(`github:${userOrOrg}/${repositoryName}`);
            })();
        }
        walk: {
            if (!(nodeModuleName in denoPorts)) {
                break walk;
            }
            const getValidImportUrlFactoryResult = await (0, exports.getValidImportUrlFactory)({
                "moduleAddress": ModuleAddress_1.ModuleAddress.parse(denoPorts[nodeModuleName]),
                "desc": "MATCH VERSION INSTALLED IN NODE_MODULES",
                version
            });
            if (!getValidImportUrlFactoryResult.couldConnect) {
                log([
                    `WARNING: Even if the port ${denoPorts[nodeModuleName]}`,
                    `was specified for ${nodeModuleName} we couldn't connect to the repo`
                ]);
                break walk;
            }
            const { versionFallbackWarning, getValidImportUrl } = getValidImportUrlFactoryResult;
            if (versionFallbackWarning) {
                log(versionFallbackWarning);
            }
            return {
                "result": "SUCCESS",
                getValidImportUrl
            };
        }
        walk: {
            if (gitHubRepo === undefined) {
                break walk;
            }
            const getValidImportUrlFactoryResult = await (0, exports.getValidImportUrlFactory)({
                "moduleAddress": gitHubRepo,
                "desc": "MATCH VERSION INSTALLED IN NODE_MODULES",
                version
            });
            if (!getValidImportUrlFactoryResult.couldConnect) {
                break walk;
            }
            const { versionFallbackWarning, getValidImportUrl } = getValidImportUrlFactoryResult;
            if (versionFallbackWarning) {
                log(versionFallbackWarning);
            }
            if (isInUserProvidedPort(nodeModuleName)) {
                log([`NOTE: ${nodeModuleName} is a denoified module,`, `there is no need for an entry for in package.json denoPorts`].join(" "));
            }
            return {
                result: "SUCCESS",
                getValidImportUrl
            };
        }
        return {
            "result": "SUCCESS",
            "getValidImportUrl": params => Promise.resolve(`npm:${nodeModuleName}@${version}${(() => {
                switch (params.target) {
                    case "DEFAULT EXPORT":
                        return "";
                    case "SPECIFIC FILE":
                        return `/${params.specificImportPath}`;
                }
            })()}`)
        };
    });
    return { resolveNodeModuleToDenoModule };
}
exports.resolveNodeModuleToDenoModuleFactory = resolveNodeModuleToDenoModuleFactory;
/** Exported only for tests purpose */
exports.getValidImportUrlFactory = (() => {
    /**
     * Perform no check, just synchronously assemble the url
     * from a ModuleAddress, a branch and a path to file.
     * */
    function buildUrlFactory(params) {
        const { moduleAddress } = params;
        const buildUrl = (() => {
            switch (moduleAddress.type) {
                case "GITHUB REPO":
                    return (candidateBranch, pathToFile) => (0, urlJoin_1.urlJoin)("https://raw.githubusercontent.com", moduleAddress.userOrOrg, moduleAddress.repositoryName, candidateBranch, (0, toPosix_1.toPosix)(pathToFile));
                case "DENO.LAND URL":
                    return (candidateBranch, pathToFile) => (0, urlJoin_1.urlJoin)([moduleAddress.baseUrlWithoutBranch.replace(/\/$/, ""), `@${candidateBranch}`].join(""), (0, toPosix_1.toPosix)(pathToFile));
                case "GITHUB-RAW URL":
                    return (candidateBranch, pathToFile) => (0, urlJoin_1.urlJoin)(moduleAddress.baseUrlWithoutBranch.replace(/\/$/, ""), candidateBranch, (0, toPosix_1.toPosix)(pathToFile));
            }
        })();
        return { buildUrl };
    }
    async function* candidateBranches(params) {
        var _a;
        const { moduleAddress } = params;
        let fallback = false;
        if (moduleAddress.type === "DENO.LAND URL" && moduleAddress.isStd) {
            yield [await (0, getCurrentStdVersion_1.getCurrentStdVersion)(), fallback];
            return undefined;
        }
        if (params.desc === "MATCH VERSION INSTALLED IN NODE_MODULES") {
            const { version } = params;
            yield ["v" + version, fallback];
            yield [version, fallback];
            fallback = { version };
        }
        if (moduleAddress.branch !== undefined) {
            yield [moduleAddress.branch, fallback];
        }
        switch (moduleAddress.type) {
            case "GITHUB-RAW URL":
                return undefined;
            case "GITHUB REPO":
                const latestTag = await (0, githubTags_1.getLatestTag)({
                    "owner": moduleAddress.userOrOrg,
                    "repo": moduleAddress.repositoryName
                });
                if (latestTag !== undefined) {
                    yield [latestTag, fallback];
                }
                yield [
                    await (0, get_github_default_branch_name_1.getGithubDefaultBranchName)({
                        "owner": moduleAddress.userOrOrg,
                        "repo": moduleAddress.repositoryName
                    }),
                    fallback
                ];
                break;
            case "DENO.LAND URL":
                if (moduleAddress.branch !== undefined) {
                    break;
                }
                if (moduleAddress.isStd) {
                    yield [
                        await (0, get_github_default_branch_name_1.getGithubDefaultBranchName)({
                            "owner": "denoland",
                            "repo": "deno"
                        }),
                        fallback
                    ];
                }
                else {
                    const latestVersion = (_a = (await (0, getThirdPartyDenoModuleInfos_1.getThirdPartyDenoModuleInfos)({
                        "denoModuleName": moduleAddress.baseUrlWithoutBranch.split("/").reverse()[0]
                    }))) === null || _a === void 0 ? void 0 : _a.latestVersion;
                    if (latestVersion === undefined) {
                        break;
                    }
                    yield [latestVersion, fallback];
                }
                break;
        }
    }
    const getTsconfigOutDir = (0, addCache_1.addCache)(async (params) => {
        var _a;
        const { moduleAddress, gitTag } = params;
        const { buildUrl } = buildUrlFactory({ moduleAddress });
        const tsconfigJson = await (0, node_fetch_1.default)(buildUrl(gitTag, "tsconfig.json")).then(res => (`${res.status}`.startsWith("2") ? res.text() : undefined), () => undefined);
        if (tsconfigJson === undefined) {
            return undefined;
        }
        const outDir = (_a = commentJson.parse(tsconfigJson)["compilerOptions"]) === null || _a === void 0 ? void 0 : _a["outDir"];
        if (typeof outDir !== "string") {
            return undefined;
        }
        return path.normalize((0, toPosix_1.toPosix)(outDir));
    });
    const { getDenoifyOutDir } = (() => {
        const getExplicitDenoifyOutDir = (0, addCache_1.addCache)(async (params) => {
            var _a;
            const { gitTag, moduleAddress } = params;
            const { buildUrl } = buildUrlFactory({ moduleAddress });
            const denoifyOut = (_a = (0, parseParams_1.parseAsDenoifyConfig)({
                "configFileType": await (0, fileAndContent_1.default)({
                    "getConfigFileRawContent": async (file) => await (0, node_fetch_1.default)(buildUrl(gitTag, file)).then(res => (`${res.status}`.startsWith("2") ? res.text() : undefined), () => undefined)
                })
            })) === null || _a === void 0 ? void 0 : _a.out;
            if (denoifyOut === undefined) {
                return undefined;
            }
            return path.normalize((0, toPosix_1.toPosix)(denoifyOut));
        });
        const getDenoifyOutDir = (0, addCache_1.addCache)(async (params) => {
            const { gitTag, moduleAddress } = params;
            explicitely_specified: {
                const denoifyOutDir = await getExplicitDenoifyOutDir({ moduleAddress, gitTag });
                if (denoifyOutDir === undefined) {
                    break explicitely_specified;
                }
                return denoifyOutDir;
            }
            default_based_on_tsconfig_outDir: {
                const tsconfigOutDir = await getTsconfigOutDir({ moduleAddress, gitTag });
                if (tsconfigOutDir === undefined) {
                    break default_based_on_tsconfig_outDir;
                }
                return path.join(path.dirname(tsconfigOutDir), // .
                `deno_${path.basename(tsconfigOutDir)}` //deno_dist
                ); // deno_dist
            }
            return undefined;
        });
        return { getDenoifyOutDir };
    })();
    async function resolveVersion(params) {
        const { moduleAddress } = params;
        const { buildUrl } = buildUrlFactory({ moduleAddress });
        for await (const [candidateBranch, fallback] of candidateBranches(params)) {
            let indexUrl;
            switch (moduleAddress.type) {
                case "DENO.LAND URL":
                case "GITHUB-RAW URL": {
                    indexUrl = buildUrl(candidateBranch, moduleAddress.pathToIndex);
                    if (!(await (0, is404_1.is404)(indexUrl))) {
                        break;
                    }
                    continue;
                }
                case "GITHUB REPO": {
                    const denoifyOutDir = await getDenoifyOutDir({ moduleAddress, "gitTag": candidateBranch });
                    if (denoifyOutDir === undefined) {
                        continue;
                    }
                    indexUrl = buildUrl(candidateBranch, path.join(denoifyOutDir, "mod.ts"));
                    if (await (0, is404_1.is404)(indexUrl)) {
                        continue;
                    }
                    break;
                }
            }
            return {
                "branchForVersion": candidateBranch,
                "versionFallbackWarning": !fallback
                    ? undefined
                    : `Can't lookup version ${fallback.version} for module ${JSON.stringify(moduleAddress)}, falling back to ${candidateBranch}`,
                indexUrl
            };
        }
        return undefined;
    }
    const getValidImportUrlFactory = (0, addCache_1.addCache)(async (params) => {
        const { moduleAddress } = params;
        const { buildUrl } = buildUrlFactory({ moduleAddress });
        const versionResolutionResult = await resolveVersion(params);
        if (versionResolutionResult === undefined) {
            return { "couldConnect": false };
        }
        const { branchForVersion, versionFallbackWarning, indexUrl } = versionResolutionResult;
        const denoifyOutDir = moduleAddress.type !== "GITHUB REPO" ? undefined : await getDenoifyOutDir({ moduleAddress, "gitTag": branchForVersion });
        const getValidImportUrl = (0, addCache_1.addCache)((0, tsafe_1.id)(async (params) => {
            if (params.target === "DEFAULT EXPORT") {
                return indexUrl;
            }
            const { specificImportPath } = params;
            let url = await (async () => {
                const pathToFile = await (async () => {
                    switch (moduleAddress.type) {
                        case "DENO.LAND URL":
                            return moduleAddress.isStd
                                ? `${moduleAddress.pathToIndex.replace(/\.ts$/, "")}/${specificImportPath}.ts`
                                : `${specificImportPath}.ts`;
                        case "GITHUB-RAW URL":
                            return `${specificImportPath}.ts`;
                        case "GITHUB REPO":
                            //NOTE: resolveVersion was successful so we can assert that:
                            (0, assert_1.assert)(denoifyOutDir !== undefined);
                            const tsconfigOutDir = await getTsconfigOutDir({ moduleAddress, "gitTag": branchForVersion });
                            return (path.join(denoifyOutDir, //deno_dist
                            tsconfigOutDir !== undefined &&
                                (0, isInsideOrIsDir_1.isInsideOrIsDir)({ "dirPath": tsconfigOutDir, "fileOrDirPath": specificImportPath })
                                ? path.relative(tsconfigOutDir, // dist
                                specificImportPath // dist/tools/typeSafety
                                ) //  tools/typeSafety
                                : specificImportPath // tools/typeSafety ( when using enable short path )
                            ) + // deno_dist/tool/typeSafety
                                ".ts"); // deno_dist/tool/typeSafety.ts
                    }
                })();
                return buildUrl(branchForVersion, pathToFile);
            })();
            walk: {
                if (await (0, is404_1.is404)(url)) {
                    break walk;
                }
                return url;
            }
            url = url.replace(/\.ts$/, "/index.ts");
            // https://.../deno_dist/tool/typeSafety/index.ts
            walk: {
                if (await (0, is404_1.is404)(url)) {
                    break walk;
                }
                return url;
            }
            throw new Error(`Can't locate ${specificImportPath} from ${JSON.stringify(moduleAddress)}`);
        }));
        const rawGitHubUserContentUrlToDenoLandXUrl = (0, addCache_1.addCache)(async (params) => {
            const { validRawGitHubUserContentUrl, denoifyOutDir } = params;
            // https://raw.githubusercontent.com/garronej/tsafe/v0.10.1/deno_dist/assert.ts;
            // https://deno.land/x/tsafe@v0.10.1/assert.ts
            const regExpMatchArray = validRawGitHubUserContentUrl.match(/^https:\/\/raw\.githubusercontent\.com\/[^\/]+\/([^\/]+)+\/([^\/]+)\/(.*)$/);
            (0, assert_1.assert)(regExpMatchArray !== null);
            const [, repoName, version, fullPathToFile] = regExpMatchArray;
            for (const moduleName of [repoName.replace(/-/g, "_"), repoName.replace(/-/g, "")]) {
                const buildDenoLandXUrl = (pathToFile) => (0, urlJoin_1.urlJoin)("https://deno.land/x", `${moduleName}@${version}`, (0, toPosix_1.toPosix)(pathToFile));
                for (const pathToFile of [
                    (0, isInsideOrIsDir_1.isInsideOrIsDir)({ "dirPath": denoifyOutDir, "fileOrDirPath": fullPathToFile })
                        ? path.relative(denoifyOutDir, fullPathToFile)
                        : undefined,
                    fullPathToFile
                ].filter((0, exclude_1.exclude)(undefined))) {
                    const denoLandXUrl = buildDenoLandXUrl(pathToFile);
                    const fetchResponse = await (0, node_fetch_1.default)(denoLandXUrl, { "timeout": 4000 });
                    if (fetchResponse.status === 404 || fetchResponse.status === 400) {
                        continue;
                    }
                    const [denoLandXRawFileContent, gitHubUserContentFileContent] = await Promise.all([
                        fetchResponse.text(),
                        (0, node_fetch_1.default)(validRawGitHubUserContentUrl).then(resp => resp.text())
                    ]);
                    if (denoLandXRawFileContent !== gitHubUserContentFileContent) {
                        continue;
                    }
                    return denoLandXUrl;
                }
            }
            return validRawGitHubUserContentUrl;
        });
        return {
            "couldConnect": true,
            versionFallbackWarning,
            "getValidImportUrl": moduleAddress.type !== "GITHUB REPO"
                ? getValidImportUrl
                : async (params) => rawGitHubUserContentUrlToDenoLandXUrl({
                    "validRawGitHubUserContentUrl": await getValidImportUrl(params),
                    "denoifyOutDir": ((0, assert_1.assert)(denoifyOutDir !== undefined), denoifyOutDir)
                })
        };
    });
    return { getValidImportUrlFactory };
})().getValidImportUrlFactory;
//# sourceMappingURL=resolveNodeModuleToDenoModule.js.map