"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.denoify = void 0;
const denoifySingleFile_1 = require("./denoifySingleFile");
const transformCodebase_1 = require("../tools/transformCodebase");
const resolveNodeModuleToDenoModule_1 = require("./resolveNodeModuleToDenoModule");
const fs = require("fs");
const path = require("path");
const commentJson = require("comment-json");
const denoifyImportExportStatement_1 = require("./denoifyImportExportStatement");
const isInsideOrIsDir_1 = require("../tools/isInsideOrIsDir");
const getInstalledVersionPackageJson_1 = require("./getInstalledVersionPackageJson");
const toPosix_1 = require("../tools/toPosix");
const tsafe_1 = require("tsafe");
const resolvePathsWithWildcards_1 = require("../tools/resolvePathsWithWildcards");
const partition_1 = require("evt/tools/reducers/partition");
const fsCopy_1 = require("../tools/fsCopy");
const parseParams_1 = require("./config/parseParams");
async function denoify(params) {
    var _a, _b, _c;
    process.chdir((_a = params.projectPath) !== null && _a !== void 0 ? _a : ".");
    const srcDirPath = params.srcDirPath !== undefined ? params.srcDirPath : ["src", "lib"].find(sourceDirPath => fs.existsSync(sourceDirPath));
    console.log(`Denoify is reading sources files from ${srcDirPath}`);
    if (!srcDirPath) {
        throw new Error("No src directory found");
    }
    const packageJsonParsed = JSON.parse(fs.readFileSync("package.json").toString("utf8"));
    const denoifyParams = await (0, parseParams_1.getDenoifyParamsWithCosmiconfig)();
    const tsconfigOutDir = getTsConfigOutDir();
    const denoDistPath = (() => {
        if (params.denoDistPath !== undefined) {
            return params.denoDistPath;
        }
        if ((denoifyParams === null || denoifyParams === void 0 ? void 0 : denoifyParams.out) !== undefined) {
            return denoifyParams === null || denoifyParams === void 0 ? void 0 : denoifyParams.out;
        }
        if (tsconfigOutDir !== undefined) {
            return path.join(path.dirname(tsconfigOutDir), `deno_${path.basename(tsconfigOutDir)}`);
        }
        throw new Error(`You should specify output directory by --out option or specify "outDir" in tsconfig.json`);
    })();
    console.log(`Deno distribution will be generated at ${denoDistPath}`);
    const { denoifySingleFile } = (0, denoifySingleFile_1.denoifySingleFileFactory)((() => {
        const { getInstalledVersionPackageJson } = (0, getInstalledVersionPackageJson_1.getInstalledVersionPackageJsonFactory)({
            "projectPath": "."
        });
        const { denoifyImportExportStatement } = (0, denoifyImportExportStatement_1.denoifyImportExportStatementFactory)((() => {
            var _a, _b, _c;
            const { resolveNodeModuleToDenoModule } = (0, resolveNodeModuleToDenoModule_1.resolveNodeModuleToDenoModuleFactory)({
                "userProvidedPorts": (_a = denoifyParams === null || denoifyParams === void 0 ? void 0 : denoifyParams.ports) !== null && _a !== void 0 ? _a : {},
                "dependencies": (_b = packageJsonParsed["dependencies"]) !== null && _b !== void 0 ? _b : {},
                "devDependencies": (_c = packageJsonParsed["devDependencies"]) !== null && _c !== void 0 ? _c : {},
                "log": console.log,
                getInstalledVersionPackageJson
            });
            return (0, tsafe_1.id)({
                "getDestDirPath": ({ dirPath }) => path.join(denoDistPath, path.relative(srcDirPath, dirPath)),
                resolveNodeModuleToDenoModule,
                "userProvidedReplacerPath": denoifyParams === null || denoifyParams === void 0 ? void 0 : denoifyParams.replacer,
                getInstalledVersionPackageJson
            });
        })());
        return { denoifyImportExportStatement };
    })());
    await (0, transformCodebase_1.transformCodebase)({
        srcDirPath,
        "destDirPath": denoDistPath,
        "transformSourceCodeString": async ({ sourceCode, filePath }) => {
            if (/\.deno\.tsx?$/i.test(filePath)) {
                const nodeFilePath = filePath.replace(/\.deno\.ts/i, ".ts");
                if (fs.existsSync(nodeFilePath)) {
                    return undefined;
                }
                return {
                    "modifiedSourceCode": sourceCode,
                    "newFileName": path.basename(nodeFilePath)
                };
            }
            if (!/\.(?:ts|tsx|js|jsx)$/i.test(filePath)) {
                return { "modifiedSourceCode": sourceCode };
            }
            const denoVersionFilePath = (() => {
                const split = filePath.split(".");
                split.splice(split.length - 1, 0, "deno");
                return split.join(".");
            })();
            if (fs.existsSync(denoVersionFilePath)) {
                return {
                    "modifiedSourceCode": fs.readFileSync(denoVersionFilePath).toString("utf8")
                };
            }
            if (/^\s*\/\/\s*@denoify-ignore/.test(sourceCode)) {
                return undefined;
            }
            return {
                "modifiedSourceCode": await denoifySingleFile({
                    sourceCode,
                    "dirPath": path.dirname(filePath)
                })
            };
        }
    });
    generateModFile({
        packageJsonParsed,
        tsconfigOutDir,
        denoDistPath,
        srcDirPath,
        "explicitlyProvidedIndexFilePath": (_b = params.indexFilePath) !== null && _b !== void 0 ? _b : denoifyParams === null || denoifyParams === void 0 ? void 0 : denoifyParams.index
    });
    {
        const includes = ((_c = denoifyParams === null || denoifyParams === void 0 ? void 0 : denoifyParams.includes) !== null && _c !== void 0 ? _c : ["README.md", "LICENSE"]).map(pathOrObj => typeof pathOrObj === "string"
            ? path.normalize(pathOrObj)
            : {
                ...pathOrObj,
                "src": path.normalize(pathOrObj.src)
            });
        const [strIncludes, objIncludes] = (0, partition_1.arrPartition)(includes, (include) => typeof include === "string");
        (await (0, resolvePathsWithWildcards_1.resolvePathsWithWildcards)({
            "pathWithWildcards": strIncludes
        })).forEach(resolvedPath => (0, fsCopy_1.fsCopy)(resolvedPath, path.join(denoDistPath, resolvedPath)));
        objIncludes.forEach(({ src, destDir, destBasename }) => (0, fsCopy_1.fsCopy)(src, path.join(denoDistPath, path.join(destDir !== null && destDir !== void 0 ? destDir : path.dirname(src), destBasename !== null && destBasename !== void 0 ? destBasename : path.basename(src)))));
    }
}
exports.denoify = denoify;
function getTsConfigOutDir() {
    const parsedTsCompile = commentJson.parse(fs.readFileSync("tsconfig.json").toString("utf8"));
    const { outDir } = parsedTsCompile["compilerOptions"];
    if (!outDir) {
        return;
    }
    return path.normalize(outDir);
}
function generateModFile(params) {
    const { denoDistPath, packageJsonParsed, tsconfigOutDir, explicitlyProvidedIndexFilePath, srcDirPath } = params;
    const indexFileRelativePath = getIndexFileRelativePath({
        packageJsonParsed,
        tsconfigOutDir,
        explicitlyProvidedIndexFilePath,
        srcDirPath
    });
    //No need to generate a mod.ts files, user have explicitly provided one.
    if (fs.existsSync(path.join(srcDirPath, "mod.ts"))) {
        return;
    }
    if (indexFileRelativePath === undefined) {
        console.warn([
            `Denoify did not generate "mod.ts" file because your index wasn't found. You have two options:`,
            `1) You may create ${path.join(srcDirPath, "mod.ts")} it will be denoified and moved to ${denoDistPath}.`,
            `2) You can also specify where is your index using the denoify.index field in package.json`
        ].join("\n"));
        return;
    }
    if (fs.existsSync(path.resolve(denoDistPath, indexFileRelativePath))) {
        fs.writeFileSync(path.join(denoDistPath, "mod.ts"), Buffer.from(`export * from "${indexFileRelativePath.replace(/^(:?\.\/)?/, "./")}";`, "utf8"));
    }
}
/** Relative to the src/ dir */
function getIndexFileRelativePath(params) {
    const { packageJsonParsed, tsconfigOutDir, explicitlyProvidedIndexFilePath, srcDirPath } = params;
    if (explicitlyProvidedIndexFilePath !== undefined) {
        return path.relative(srcDirPath, (0, toPosix_1.toPosix)(explicitlyProvidedIndexFilePath));
    }
    if (tsconfigOutDir === undefined) {
        return;
    }
    if (!("main" in packageJsonParsed)) {
        return;
    }
    if (!(0, isInsideOrIsDir_1.isInsideOrIsDir)({
        "dirPath": tsconfigOutDir,
        "fileOrDirPath": path.normalize(packageJsonParsed["main"])
    })) {
        return;
    }
    const indexFileRelativePath = (0, toPosix_1.toPosix)(path
        .relative(tsconfigOutDir, path.normalize(packageJsonParsed["main"]) // ./dist/lib/index.js
    ) // ./lib/index.js, NOTE: The the extension is commonly .js but it can be .cjs, .jsx...
        .replace(/\.[^.]+$/i, ".ts") // ./lib/index.ts
    );
    return indexFileRelativePath;
}
//# sourceMappingURL=denoify.js.map