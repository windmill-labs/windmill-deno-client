"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDenoifyParamsWithCosmiconfig = exports.parseAsDenoifyConfig = exports.parseAsDenoifyParams = void 0;
const fs = require("fs");
const YAML = require("yaml");
const cosmiconfig_1 = require("cosmiconfig");
const _1 = require(".");
function parseAsStringElseUndefined(param) {
    return typeof param === "string" ? param : undefined;
}
function parseAsStringElseThrow({ param, type }) {
    if (typeof param === "string") {
        return param;
    }
    throw new Error([
        "Denoify configuration Error",
        `Expect ${type} to be string, got ${param} instead`,
        "See: https://github.com/garronej/my_dummy_npm_and_deno_module"
    ].join("\n"));
}
function parseAsDenoifyParams(denoifyParams) {
    if (denoifyParams === undefined) {
        return undefined;
    }
    const { includes } = denoifyParams;
    return {
        "replacer": parseAsStringElseUndefined(denoifyParams.replacer),
        "out": parseAsStringElseUndefined(denoifyParams.out),
        "index": parseAsStringElseUndefined(denoifyParams.index),
        "includes": !Array.isArray(includes)
            ? undefined
            : includes.map(elem => typeof elem === "string"
                ? elem
                : {
                    "destDir": parseAsStringElseUndefined(elem.destDir),
                    "destBasename": parseAsStringElseUndefined(elem.destBasename),
                    "src": parseAsStringElseThrow({
                        "param": elem.src,
                        "type": "src in includes array"
                    })
                }),
        "ports": denoifyParams.ports !== undefined || denoifyParams.ports !== null
            ? undefined
            : Object.entries(denoifyParams.ports).reduce((prev, [portName, value]) => ({
                ...prev,
                [portName]: parseAsStringElseThrow({
                    "param": value,
                    "type": "value of ports object"
                })
            }), {})
    };
}
exports.parseAsDenoifyParams = parseAsDenoifyParams;
function parseAsDenoifyConfig({ configFileType }) {
    switch (configFileType.type) {
        case "absent":
            return undefined;
        case "yaml": {
            const parsed = YAML.parse(configFileType.configFileRawContent);
            return parseAsDenoifyParams(configFileType.configFileBasename !== _1.default.packageJson ? parsed : parsed.denoify);
        }
        case "js": {
            const denoifyCacheDirPath = "node_modules/.cache/denoify/cacheDirPath";
            if (!fs.existsSync(denoifyCacheDirPath)) {
                fs.mkdirSync(denoifyCacheDirPath, {
                    "recursive": true
                });
            }
            const path = `${process.cwd()}/${denoifyCacheDirPath}/config.js`;
            fs.writeFileSync(path, configFileType.configFileRawContent);
            // cosmiconfig internally uses import-fresh to parse JS config
            // import-fresh only support commonjs export, so we can use require
            return parseAsDenoifyParams(require(path));
        }
    }
}
exports.parseAsDenoifyConfig = parseAsDenoifyConfig;
async function getDenoifyParamsWithCosmiconfig() {
    var _a;
    const explorer = (0, cosmiconfig_1.cosmiconfig)("denoify");
    const search = await explorer.search();
    if (search) {
        console.log(`Configurations from ${search.filepath} are used`);
    }
    return parseAsDenoifyParams((_a = search === null || search === void 0 ? void 0 : search.config) !== null && _a !== void 0 ? _a : undefined);
}
exports.getDenoifyParamsWithCosmiconfig = getDenoifyParamsWithCosmiconfig;
//# sourceMappingURL=parseParams.js.map