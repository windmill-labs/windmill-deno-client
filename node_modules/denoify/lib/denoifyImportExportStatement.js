"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.denoifyImportExportStatementFactory = void 0;
const path = require("path");
const tsafe_1 = require("tsafe");
const fs = require("fs");
const ParsedImportExportStatement_1 = require("./types/ParsedImportExportStatement");
const replacer_1 = require("./replacer");
const getProjectRoot_1 = require("../tools/getProjectRoot");
/**
 * examples:
 * import { Evt } from "evt" -> import {Â Evt } from "https://deno.land/x/evt@.../mod.ts"
 * import { id } "evt/dist/tools/typeSafety" -> "https://deno.land/x/evt@.../deno_dist/tools/typeSafety/index.ts"
 * import * as interfaces from "./interfaces" -> import * as interfaces from "./interfaces/index.ts"
 */
function denoifyImportExportStatementFactory(params) {
    const { userProvidedReplacerPath, getDestDirPath, resolveNodeModuleToDenoModule, getInstalledVersionPackageJson } = params;
    const { consumeExecutableReplacer: consumeExecutableBuiltinsReplacer } = (0, replacer_1.consumeExecutableReplacerFactory)({
        "executableFilePath": path.join((0, getProjectRoot_1.getProjectRoot)(), fs.existsSync(path.join((0, getProjectRoot_1.getProjectRoot)(), "dist")) ? "dist" : "", "bin", "replacer", "index.js")
    });
    const { consumeExecutableReplacer: consumeExecutableUserProvidedReplacer } = userProvidedReplacerPath === undefined
        ? { "consumeExecutableReplacer": undefined }
        : (0, replacer_1.consumeExecutableReplacerFactory)({
            "executableFilePath": userProvidedReplacerPath
        });
    async function denoifyImportExportStatement(params) {
        const { dirPath, importExportStatement } = params;
        const parsedImportExportStatement = ParsedImportExportStatement_1.ParsedImportExportStatement.parse(params.importExportStatement);
        if (parsedImportExportStatement.parsedArgument.type === "URL") {
            //There is no reason to have url import in the source
            //file as url import are not supported by node it does not
            //hurt to leave the import unchanged. See #7
            return importExportStatement;
        }
        const stringify = (argument) => ParsedImportExportStatement_1.ParsedImportExportStatement.stringify({
            ...parsedImportExportStatement,
            "parsedArgument": ParsedImportExportStatement_1.ParsedImportExportStatement.ParsedArgument.parse(argument)
        });
        if (parsedImportExportStatement.parsedArgument.type === "PROJECT LOCAL FILE") {
            const { relativePath } = parsedImportExportStatement.parsedArgument;
            if (/\.json$/i.test(relativePath)) {
                return stringify(relativePath);
            }
            for (const ext of ["ts", "tsx"]) {
                if (fs.existsSync(path.join(dirPath, `${relativePath}.${ext}`))) {
                    return stringify(`${relativePath}.${ext}`);
                }
            }
            // relative esm module import
            const esmReg = /\.m?js$/;
            if (esmReg.test(path.extname(relativePath)) && fs.existsSync(path.join(dirPath, relativePath.replace(esmReg, ".ts")))) {
                return stringify(relativePath.replace(esmReg, ".ts"));
            }
            const out = path.posix.join(relativePath, "index.ts");
            return stringify(out.startsWith(".") ? out : `./${out}`);
        }
        //NOTE: Should be inferable...
        (0, tsafe_1.assert)((0, tsafe_1.is)(parsedImportExportStatement));
        const { nodeModuleName, specificImportPath } = parsedImportExportStatement.parsedArgument;
        const { version } = await getInstalledVersionPackageJson({ nodeModuleName }).catch(() => ({ "version": "0.0.0" }));
        for (const consumeExecutableReplacer of [consumeExecutableUserProvidedReplacer, consumeExecutableBuiltinsReplacer]) {
            const result = await (consumeExecutableReplacer === null || consumeExecutableReplacer === void 0 ? void 0 : consumeExecutableReplacer({
                parsedImportExportStatement,
                version,
                "destDirPath": getDestDirPath({ dirPath })
            }));
            if (result === undefined) {
                continue;
            }
            return result;
        }
        const nodeToDenoModuleResolutionResult = await resolveNodeModuleToDenoModule({ nodeModuleName });
        if (nodeToDenoModuleResolutionResult.result === "UNKNOWN BUILTIN") {
            return stringify(`${ParsedImportExportStatement_1.ParsedImportExportStatement.ParsedArgument.stringify(parsedImportExportStatement.parsedArgument)} DENOIFY: UNKNOWN NODE BUILTIN`);
        }
        const { getValidImportUrl } = nodeToDenoModuleResolutionResult;
        return stringify(await getValidImportUrl(!specificImportPath ? { "target": "DEFAULT EXPORT" } : { "target": "SPECIFIC FILE", specificImportPath }));
    }
    return { denoifyImportExportStatement };
}
exports.denoifyImportExportStatementFactory = denoifyImportExportStatementFactory;
//# sourceMappingURL=denoifyImportExportStatement.js.map