#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = void 0;
const path_1 = require("path");
const getIsDryRun_1 = require("./lib/getIsDryRun");
const fs = require("fs");
const commentJson = require("comment-json");
const removeFromGitignore_1 = require("../tools/removeFromGitignore");
const toPosix_1 = require("../tools/toPosix");
const assert_1 = require("tsafe/assert");
const parseParams_1 = require("../lib/config/parseParams");
const fileAndContent_1 = require("../lib/config/fileAndContent");
const { getDenoifyOutDir } = (() => {
    async function getExplicitDenoifyOutDir(params) {
        var _a;
        const { moduleDirPath } = params;
        const denoifyOut = (_a = (0, parseParams_1.parseAsDenoifyConfig)({
            "configFileType": await (0, fileAndContent_1.default)({
                "getConfigFileRawContent": fileBasename => {
                    const filePath = (0, path_1.join)(moduleDirPath, fileBasename);
                    if (!fs.existsSync(filePath)) {
                        return Promise.resolve(undefined);
                    }
                    return Promise.resolve(fs.readFileSync(filePath).toString("utf8"));
                }
            })
        })) === null || _a === void 0 ? void 0 : _a.out;
        if (denoifyOut === undefined) {
            return undefined;
        }
        return (0, path_1.normalize)((0, toPosix_1.toPosix)(denoifyOut));
    }
    function getTsconfigOutDir(params) {
        var _a;
        const { moduleDirPath } = params;
        const tsconfigJson = fs.readFileSync((0, path_1.join)(moduleDirPath, "tsconfig.json")).toString("utf8");
        const outDir = (_a = commentJson.parse(tsconfigJson)["compilerOptions"]) === null || _a === void 0 ? void 0 : _a["outDir"];
        if (typeof outDir !== "string") {
            return undefined;
        }
        return (0, path_1.normalize)((0, toPosix_1.toPosix)(outDir));
    }
    async function getDenoifyOutDir(params) {
        const { moduleDirPath } = params;
        explicitely_specified: {
            const denoifyOutDir = await getExplicitDenoifyOutDir({ moduleDirPath });
            if (denoifyOutDir === undefined) {
                break explicitely_specified;
            }
            return denoifyOutDir;
        }
        default_based_on_tsconfig_outDir: {
            const tsconfigOutDir = getTsconfigOutDir({ moduleDirPath });
            if (tsconfigOutDir === undefined) {
                break default_based_on_tsconfig_outDir;
            }
            return (0, path_1.join)((0, path_1.dirname)(tsconfigOutDir), // .
            `deno_${(0, path_1.basename)(tsconfigOutDir)}` //deno_dist
            ); // deno_dist
        }
        return undefined;
    }
    return { getDenoifyOutDir };
})();
/**
 * To disable dry run mode  DRY_RUN=1 env variable must be set.
 * This function Change change the working directory.
 * */
async function run(params) {
    const { moduleDirPath, isDryRun } = params;
    const denoifyOutDir = await getDenoifyOutDir({ moduleDirPath });
    (0, assert_1.assert)(denoifyOutDir !== undefined);
    if (!fs.existsSync(denoifyOutDir)) {
        console.log("exit 1");
        return;
    }
    const { fixedGitignoreRaw } = (0, removeFromGitignore_1.removeFromGitignore)({
        "pathToTargetModule": moduleDirPath,
        "fileOrDirPathsToAccept": [denoifyOutDir]
    });
    if (!fixedGitignoreRaw) {
        console.log("exit 2");
        return;
    }
    console.log(`\n${isDryRun ? "(dry)" : ""} .gitignore:\n\n${fixedGitignoreRaw}`);
    if (isDryRun) {
        return;
    }
    fs.writeFileSync(".gitignore", Buffer.from(fixedGitignoreRaw, "utf8"));
}
exports.run = run;
if (require.main === module) {
    process.once("unhandledRejection", error => {
        throw error;
    });
    const { isDryRun } = (0, getIsDryRun_1.getIsDryRun)();
    run({
        "moduleDirPath": ".",
        isDryRun
    });
}
//# sourceMappingURL=remove_deno_dist_from_gitignore.js.map